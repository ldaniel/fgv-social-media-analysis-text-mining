---
title: "Tarefa Aula 1 – Exploração de SNA em R"
output:
  html_document:
    df_print: paged
    toc: yes
    theme: cosmo
    highlight: tango
    number_sections: yes
  word_document:
    highlight: tango
    reference_docx: word-styles-reference.docx
    toc: yes
date: "Novembro de 2019"
---

```{r setup_evaluation, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.pos =  "h")
knitr::opts_knit$set(root.dir = "./")

# loading markdown libraries
library(rmarkdown)
library(knitr)
library(flextable)
library(officer)

# loading basic libraries
library(dplyr)
library(lubridate)
library(stringr)
library(readxl)

# loading plot libraries
library(ggplot2)
library(ggpubr)
library(ggdendro)
library(gridExtra)

# loading libraries for SNA (Social Network Analysis)
library(network)
library(sna)
library(rgl)
library(visNetwork)

# loading libraries for cluster
library(fpc)
library(factoextra)
library(cluster)

# setting the seed up
set.seed(42)

# setting the encoding up
options(encoding = "UTF-8")

```

*******************************************************************************

# Alunos / ID (matrícula)

\  

- <a href="https://github.com/DanielFCampos"><img src="https://avatars2.githubusercontent.com/u/31582602?s=460&v=4" title="DanielFCampos" width="40" height="40"></a> [Daniel Campos](mailto:daniel.ferraz.campos@gmail.com) / A57635769
- <a href="https://github.com/ldaniel"><img src="https://avatars2.githubusercontent.com/u/205534?s=460&v=4" title="ldaniel" width="40" height="40"></a>  [Leandro Daniel](mailto:contato@leandrodaniel.com) / A57622988
- <a href="https://github.com/RodriGonca"><img src="https://avatars2.githubusercontent.com/u/50252438?s=460&v=4" title="RodriGonca" width="40" height="40"></a> [Rodrigo Goncalves](mailto:rodrigo.goncalves@me.com) / A57566093
- <a href="https://github.com/ygorlima1"><img src="https://avatars2.githubusercontent.com/u/52429828?s=460&v=4" title="ygorlima1" width="40" height="40"></a>  [Ygor Lima](mailto:ygor_redesocial@hotmail.com) / A57549661

\  

*******************************************************************************

# Enunciado (parte 1)

\  

- Explore as rotinas Exemplo Rede.R e Exemplo Rede Two Mode.R . Rode os códigos na plataforma R utilizando como base as tabelas Rede One Mode_Tarefa Aula 1_Berrini T1.xlsx e Rede Two Mode_Tarefa Aula 1_Berrini T1.xlsx. (atenção: não são as mesmas bases trabalhadas em sala). 

- Faça pequenas modificações na tabela e veja seus resultados.

- Inclua outras análises em seu código (usando as extensões sna, network ou igraph) e comente os resultados (seja criativo!).

- Compile as saídas dos códigos (conteúdo das variáveis, gráficos, tabelas) em um documento Word (usando o modelo deste documento) e comente seus resultados (principalmente as medidas de centralidade), análises, potenciais implicações gerenciais, etc, conforme discutido em sala na Aula 1.

\  

## Explorando as rotinas de exemplo para rede one mode

\  

Como primeiro passo para o exercício proposto, vamos carregar os dados da planilha Excel **Rede One Mode_Tarefa Aula 1_Berrini T1.xlsx**. Incialmente, removeremos a primeira coluna que possui os nomes dos nós e vamos atribui-la às linhas.

\  

```{r exploration_one_mode_1, echo = TRUE, out.width = '100%'}

# carregando a planilha com os dados do exercício
rede_one_mode <- read_xlsx("../../data/raw/Rede One Mode_Tarefa Aula 1_Berrini T1.xlsx", 
                           sheet = "Exemplo Rede") %>% as.data.frame()

# removendo a coluna com os nomes dos nós
grede_one_mode <- rede_one_mode[,2:25]

# atribuindo o nome dos nós às linhas
rownames(grede_one_mode) <- rede_one_mode[,1]

```

\  

Podemos então, visualizar a rede sob a forma de um grafo.

\  

```{r plot_one_mode_1, echo = TRUE, out.width = '100%'}

gplot(grede_one_mode, 
      gmode = "graph", 
      displaylabels = TRUE, 
      edge.col = "gray", 
      usearrows = FALSE)

```


O **R** oferece várias packages para manipulação e geração de visualizações de redes. Abaixo, vemos um exemplo utilizando a library **visNetwork** com layouts alternativos e interativos.

- **layout_on_grid**

- **layout_in_circle**

- **layout_with_gem**

- **layout_as_tree**

Podemos inclusíve adicionar a opção para fazer o highlight dos nós relacionados ao selecionar um nó específico.


\  

```{r plot_one_mode_2, echo = TRUE, out.width = '100%', warning=FALSE, error=FALSE}

g_one_mode <- igraph::graph_from_adjacency_matrix(as.matrix(grede_one_mode))

p <-visIgraph(g_one_mode) %>%
      visOptions(highlightNearest = list(enabled = TRUE, degree = 1, algorithm = 'hierarchical'))

p %>% visIgraphLayout(layout = 'layout_on_grid')
p %>% visIgraphLayout(layout = 'layout_in_circle')
p %>% visIgraphLayout(layout = 'layout_with_gem')
p %>% visIgraphLayout(layout = 'layout_as_tree')

```

\  

A **SNA**, do inglês Systems Network Analysis (Análise de Sistemas de Redes), dispõe de um conjunto de métricas que auxiliam na compreensão da dinâmica dos relacionamentos existentes nas redes analisadas. Dentre elas, destacam-se as métricas de Centralidade (Centrality), que permitem a avaliação da importância de um nó (individuo/ação/postagem) dentro da rede. Na sequência, vamos explorar as métricas de centralidade: **degree**, **closeness** e **betweenness**.

\  

A **Centralidade de Grau** (Degree Centrality) representa o número de ligações que um nó possui (degree), dividido pelo número de ligações possíveis.

\  

Definimos como **Centralidade de Proximidade** (Closeness Centrality) a medida do comprimento médio dos caminhos mais curtos de um vértice para cada um dos outros vértices de um grafo.

\  

A chamada **Centralidade de Intermediação** (Betweenness Centrality) representa a quantidade de vezes que um determinado nó aparece no caminho geodésico entre dois nós da rede.

\  

A seguir, exploraremos as métricas de centralidade para a rede one mode.

\  

```{r exploration_metrics_one_mode_1, echo = TRUE, out.width = '100%'}

metricas_one_mode <- cbind(label = rownames(grede_one_mode),
                           degree = degree(grede_one_mode, gmode = "graph", cmode = "indegree"),
                           closeness = round(closeness(grede_one_mode, gmode = "graph"), 4),
                           betweenness = round(betweenness(grede_one_mode, gmode = "graph"), 4))

table_output <- flextable(as.data.frame(metricas_one_mode))
table_output <- fontsize(table_output, part = "all", size = 16)
table_output <- autofit(table_output)
table_output

```

\  

## Aplicando modificações na rede one mode e analisando os resultados

\  

Decidimos aplicar uma transofmação na rede one mode original onde setamos a matriz de vizinhança completamente randomica para avaliarmo os resultados.

Abaixo a comparação da matriz de vizinhançã origincal com a mareiz de vizinhança completamente randomizada.

```{r exploration_metrics_one_mode_1_modificado, echo = TRUE, out.width = '100%'}

set.seed(12345)

grede_one_mode_modificada <- grede_one_mode

for (i in 1:24) {
  grede_one_mode_modificada[, i] <- as.integer(sample(0:1, 24, replace = TRUE))
}

print('Rede one mode original')
grede_one_mode[1:24, 1:24] %>% as.matrix


print('Rede one mode modificada de forma randomica')
grede_one_mode_modificada[1:24, 1:24] %>% as.matrix

```

\ 

Vizualizamos o plot da rede one mode modificada (completamente randomizada) em comparação com a rede original.

```{r plot_one_mode_modificada, echo = TRUE, out.width = '100%'}

par(mfrow=c(1, 2))

gplot(grede_one_mode, 
      main = 'Rede original', 
      gmode = "graph", 
      displaylabels = TRUE, 
      edge.col = "gray", 
      usearrows = FALSE)

gplot(grede_one_mode_modificada, 
      main = 'Rede modificada', 
      gmode = "graph", 
      displaylabels = TRUE, 
      edge.col = "gray", 
      usearrows = FALSE)

par(mfrow=c(1, 1))

```

\  

A seguir, exploraremos as métricas de centralidade para a rede one mode modificada.

```{r exploration_metrics_one_mode_modificada, echo = TRUE, out.width = '100%'}

metricas_one_mode_modificada <- cbind(label = rownames(grede_one_mode_modificada),
                           degree = degree(grede_one_mode_modificada, 
                                           gmode = "graph", cmode = "indegree"),
                           closeness = round(closeness(grede_one_mode_modificada, 
                                                 gmode = "graph"), 4),
                           betweenness = round(betweenness(grede_one_mode_modificada, 
                                                     gmode = "graph"), 4))

table_output <- flextable(as.data.frame(metricas_one_mode_modificada))
table_output <- fontsize(table_output, part = "all", size = 16)
table_output <- autofit(table_output)
table_output

```

\  

## Explorando as rotinas de exemplo para rede two mode

\  

Como primeiro passo para o exercício proposto, vamos carregar os dados da planilha Excel **Rede Two Mode_Tarefa Aula 1_Berrini T1.xlsx**. Faremos um tratamento semelhante ao realizado para a rede anterior.

\  

```{r exploration_two_mode_1, echo = TRUE, out.width = '100%', warning = FALSE, error = FALSE}

# carregando a planilha com os dados do exercício
rede_two_mode <- read_xlsx("../../data/raw/Rede Two Mode_Tarefa Aula 1_Berrini T1.xlsx", 
                           sheet = "Rede 2-mode") %>% as.data.frame

names(rede_two_mode)[1] <- 'nome'

# removendo a coluna com os nomes dos nós
grede_two_mode <- rede_two_mode[,2:15]

# atribuindo o nome dos nós às linhas
rownames(grede_two_mode) <- rede_two_mode[,1]

```

\  

Visualizando a rede sob a forma de um grafo.

\  

```{r plot_two_mode_1, echo = TRUE, out.width = '100%'}

gplot(grede_two_mode, gmode = "twomode", 
      displaylabels = TRUE,
      edge.col = "gray", 
      label.cex = 0.7, 
      usearrows = FALSE)

```

\  

A seguir, exploraremos as métricas de centralidade para a rede two mode.

\  

```{r exploration_metrics_two_mode_1, echo = TRUE, out.width = '100%'}

metricas_two_mode <- cbind(degree = degree(grede_two_mode, gmode = "twomode", cmode = "indegree"),
                           closeness = round(closeness(grede_two_mode, gmode = "twomode"), 4),
                           betweenness = round(betweenness(grede_two_mode, gmode = "twomode"), 4))

table_output <- flextable(as.data.frame(metricas_two_mode))
table_output <- fontsize(table_output, part = "all", size = 16)
table_output <- autofit(table_output)
table_output

```

\  

## Aplicando modificações na rede two mode e analisando os resultados

\  

Assim como modificamos a rede one mode para uma rede randomica vamos aplicar a mesma transformação para a rede two mode.


```{r exploration_metrics_two_mode_1_modificado, echo = TRUE, out.width = '100%'}

set.seed(12345)

grede_two_mode_modificada <- grede_two_mode

for (i in 1:14) {
  grede_two_mode_modificada[, i] <- as.integer(sample(0:1, 19, replace = TRUE))
}

print('Rede one mode original (primeiras 6 linhas e colunas')
grede_two_mode[1:6, 1:6] %>% as.matrix


print('Rede one mode modificada de forma randomica (primeiras 6 linhas e colunas)')
grede_two_mode_modificada[1:6, 1:6] %>% as.matrix

```


\ 

Vizualizamos o plot da rede one mode modificada (completamente randomizada) em comparação com a rede original.

```{r plot_two_mode_modificada, echo = TRUE, out.width = '100%'}

par(mfrow=c(1, 2))

gplot(grede_two_mode, 
      main = 'Rede original', 
      gmode = "twomode", 
      displaylabels = TRUE,
      edge.col = "gray", 
      label.cex = 0.7, 
      usearrows = FALSE)

gplot(grede_two_mode_modificada, 
      main = 'Rede modificada', 
      gmode = "twomode", 
      displaylabels = TRUE,
      edge.col = "gray", 
      label.cex = 0.7, 
      usearrows = FALSE)

par(mfrow=c(1, 1))

```

\ 

```{r exploration_metrics_two_mode_1_modificada, echo = TRUE, out.width = '100%'}

metricas_two_mode_modificada <- cbind(degree = degree(grede_two_mode_modificada, 
                                                      gmode = "twomode", cmode = "indegree"),
                           closeness = round(closeness(grede_two_mode_modificada, 
                                                       gmode = "twomode"), 4),
                           betweenness = round(betweenness(grede_two_mode_modificada, 
                                                           gmode = "twomode"), 4))

table_output <- flextable(as.data.frame(metricas_two_mode_modificada))
table_output <- fontsize(table_output, part = "all", size = 16)
table_output <- autofit(table_output)
table_output

```

\  

*******************************************************************************

# Enunciado (parte 2)

\  

- **Desafio:** Baseado na tabela da Rede Two Mode desta tarefa, faça uma análise de agrupamento (cluster analysis) do tipo hierárquico aglomerativo (dendrograma) das pessoas ou dos produtos adquiridos por elas, levando em consideração apenas a estrutura de relações entre elas. Comente como implementou e discuta os resultados, comparando com a rede construída. Utilize a plataforma R e o script de exemplo de uso de Cluster Analysis em R.

\  

*Dica: após a seleção dos grupos, desenhe a rede e represente os nós das pessoas (ou produtos) com cores de acordo com o grupo correspondente.*

\  

## Analisando agrupamento do tipo hierárquico aglomerativo

\  

Como primeiro passo para o exercício proposto, vamos carregar novamente os dados da planilha Excel **Rede Two Mode_Tarefa Aula 1_Berrini T1.xlsx**.

\  

```{r exploration_cluster_1, echo = TRUE, out.width = '100%', warning = FALSE, error = FALSE}

# carregando a planilha com os dados do exercício
rede_two_mode <- read_xlsx("../../data/raw/Rede Two Mode_Tarefa Aula 1_Berrini T1.xlsx", 
                           sheet = "Rede 2-mode") %>% as.data.frame

names(rede_two_mode)[1] <- 'nome'

# atribuindo o nome dos nós às linhas
rownames(rede_two_mode) <- rede_two_mode$NA.

```

\  

O **dendrograma** é um diagrama de árvore que exibe os grupos formados por agrupamento de observações em cada passo e em seus níveis de similaridade. O nível de similaridade é medido ao longo do eixo vertical (alternativamente, você pode exibir o nível de distância) e as diferentes observações são listadas ao longo do eixo horizontal. 

\  

Utilizaremos o dendrograma para visualizar como os agrupamentos são formados em cada passo e para avaliar os níveis de similaridade (ou distância) dos agrupamentos que são formados.

\  

```{r exploration_dendrogram_1, echo = TRUE, out.width = '100%'}

# criando o cluster hierárquico (Hierarchical Clustering)
hc <- hclust(dist(rede_two_mode), "average")
hcdata <- dendro_data(hc)

# plotando dendrograma (vertical)
ggdendrogram(hcdata, rotate = TRUE, size = 2) + 
  labs(title = "Dendrograma dos Produtos por Pessoas")

# plotando dendrograma com cores, para k = 5, usando a library factoextra
fviz_dend(hc, k = 5, cex = 0.7, color_labels_by_k = TRUE, rect = TRUE)

```

\  

Para exibir os níveis de similaridade (ou distância), mantenha seu ponteiro sobre uma linha horizontal no dendrograma. O padrão de como a similaridade ou os valores de distância mudam de um passo para outro pode ajudar a escolher o agrupamento final dos seus dados. O passo onde os valores mudam abruptamente podem identificar um bom ponto para definir o agrupamento final. 

\  

A decisão sobre o agrupamento final também é chamada corte do dendrograma. O corte do dendrograma é similar ao desenho de uma linha por todo o dendrograma para especificar o agrupamento final. Você também pode comparar os dendrogramas a agrupamentos finais diferentes para determinar qual agrupamento final faz mais sentido para os dados.

\  

```{r exploration_dendrogram_2, echo = TRUE, out.width = '100%'}

# "cortando" a árvore em 3 grupos
grupos <- cutree(hc, k = 5)
grupos

```

\  

## Analisando as principais variáveis

\  

O boxplot é um tipo de diagrama construído utilizando as referências de valores mínimos e máximos, primeiro e terceiro quartil, mediana e outliers da base de dados. O boxplot tem como objetivo estudar as medidas estatística do conjunto de dados, como variabilidade, média e outliers.

\  

```{r exploration_bloxplot_1, echo = TRUE, out.width = '100%'}

# analisando as principais variáveis a partir dos grupos
<<<<<<< HEAD
boxplot(rede_two_mode$Camisa.do.Corinthians ~ grupos, col = "blue", 
        main = 'Box Plot da Camisa do Corinthians')

boxplot(rede_two_mode$Livro.Harry.Potter ~ grupos, col = "blue", 
        main = 'Box Plot do Livro do Harry Potter')

boxplot(rede_two_mode$Lista.Telefonica ~ grupos, col = "blue", 
        main = 'Box Plot da Lista Telefonica')

boxplot(rede_two_mode$Bola.de.Futebol ~ grupos, col = "blue", 
        main = 'Box Plot da Bola de Futebol')
=======
boxplot(rede_two_mode$`Camisa do Corinthians` ~ grupos, 
        col = "blue", main = 'Box Plot da Camisa do Corinthians')

boxplot(rede_two_mode$`Livro Harry Potter` ~ grupos, 
        col = "blue", main = 'Box Plot do Livro do Harry Potter')

boxplot(rede_two_mode$`Lista Telefonica` ~ grupos, 
        col = "blue", main = 'Box Plot da Lista Telefonica')

boxplot(rede_two_mode$`Bola de Futebol` ~ grupos, 
        col = "blue", main = 'Box Plot da Bola de Futebol')
>>>>>>> e1ffc2fd655cc0a1bfafb218289c0d93fe1de9d7

```

\  

## Visualizando os clusters

\  

To-do.

\  

```{r exploration_agnes_1, echo = TRUE, out.width = '100%'}

# determinando a distância euclidiana
cluster_dist <- dist(rede_two_mode, method = "euclidean")

# encontrando os clusters utilizando AGENS com o método WARD
cluster_agnes_ward <- agnes(cluster_dist, 
                       diss = TRUE, 
                       metric = 'euclidian', 
                       method = 'ward')

# plotando os clusters
fviz_cluster(list(data = rede_two_mode[,-1], 
                  cluster = cutree(cluster_agnes_ward, k = 5)),  
             show.clust.cent = TRUE)

```

\  

To-do.

\  

```{r exploration_kmeans_1, echo = TRUE, out.width = '100%'}

# encontrando kmeans, para k = 5
cluster_kmeans <- kmeans(rede_two_mode[,-1], centers = 5, nstart = 100)

# plotando os clusters
fviz_cluster(list(data = rede_two_mode[,-1], 
                  cluster = cluster_kmeans$cluster),
             show.clust.cent = TRUE)

```

\  

## Checando as estatísticas

\  

To-do.

\  

```{r exploration_cluster_stats_1, echo = TRUE, out.width = '100%'}

# estatísticas do cluster com AGNES, com método WARD
cluster.stats(cluster_dist, cutree(cluster_agnes_ward, k = 5))

```

\  

To-do.

\  

```{r exploration_cluster_stats_2, echo = TRUE, out.width = '100%'}

# estatísticas do cluster com KMEANS
cluster.stats(cluster_dist, cluster_kmeans$cluster)

```